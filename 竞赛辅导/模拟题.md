[toc]

## 烤鸡

[题目链接](https://www.luogu.org/problemnew/show/P2089)

猪猪 Hanke 特别喜欢吃烤鸡（本是同畜牲，相煎何太急！）Hanke 吃鸡很特别，为什么特别呢？因为他有 10 种配料（芥末、孜然等），每种配料可以放 1 — 3 克，任意烤鸡的美味程度为所有配料质量之和。

现在，Hanke 想要知道，美味程度为 500 时这 10 种配料的所有搭配方案。

## 迷宫

X 星球的一处迷宫游乐场建在某个小山坡上。
它是由 10x10 相互连通的小房间组成的。

房间的地板上写着一个很大的字母。
我们假设玩家是面朝上坡的方向站立，则：
L 表示走到左边的房间，
R 表示走到右边的房间，
U 表示走到上坡方向的房间，
D 表示走到下坡方向的房间。

X 星球的居民有点懒，不愿意费力思考。
他们更喜欢玩运气类的游戏。这个游戏也是如此！

开始的时候，直升机把 100 名玩家放入一个个小房间内。
玩家一定要按照地上的字母移动。

迷宫地图如下：

```
UDDLUULRUL
UURLLLRRRU
RRUURLDLRD
RUDDDDUUUU
URUDLLRRUU
DURLRLDLRL
ULLURLLRDU
RDLULLRDDD
UUDDUDUDLL
ULRDLUURRR
```

请你计算一下，最后，有多少玩家会走出迷宫? 
而不是在里边兜圈子。

## 猫和老鼠

已知猫和老鼠在一个 10*10 的方格中移动。
猫和老鼠每秒钟走一格，如果在某一秒末它们在同一格，那么猫抓住了老鼠。
注意，穿过是不算的。
移动方式为：

- 没有碰到障碍物或边缘时，沿直线走。
- 如果碰到障碍物或边缘时，用一秒钟做一个右转 90 度。

初始时都面向北方，求在下面的方格中猫需要走多少步才能抓到老鼠。

```
*...*.....
......*...
...*...*..
..........
...*.C....
*.....*...
..M......*
...*.*....
.*.*......
```

- `.` 表示空地
- `*` 表示障碍物
- `C` 表示猫
- `M` 表示老鼠


## 数独

[题目链接](https://www.luogu.org/problemnew/show/P1784)

数独是根据 9×9 盘面上的已知数字，推理出所有剩余空格的数字，并满足每一行、每一列、每一个粗线宫内的数字均含 1-9，不重复。每一道合格的数独谜题都有且仅有唯一答案，推理方法也以此为基础，任何无解或多解的题目都是不合格的。

请你推算出下面数独的正确解。

8 0 0 0 0 0 0 0 0 
0 0 3 6 0 0 0 0 0 
0 7 0 0 9 0 2 0 0 
0 5 0 0 0 7 0 0 0 
0 0 0 0 4 5 7 0 0 
0 0 0 1 0 0 0 3 0 
0 0 1 0 0 0 0 6 8 
0 0 8 5 0 0 0 1 0 
0 9 0 0 0 0 4 0 0

## 分形图

一个分形是一种在所有尺度上具有自相似性质的，带有一定的科技感的物体。物体需要不仅仅展示具体所有尺度上的相同结构，还要展示所有尺度上相同 "类型" 的结构。

盒状分形定义为以下的形式：
一个度数为 1 的盒状分形是简单的。

```
X
```

一个度数为 2 的盒状分形是

```
X X 
 X 
X X 
```

如果使用 `B(n-1)` 来代表度数为 n - 1 的盒状分形，那么度数为 n 的盒状分形可以递归地定义为以下形式

```
B(n - 1)        B(n - 1)

        B(n - 1)

B(n - 1)        B(n - 1)
```

你的任务是画出度数为 n 的盒状分形。

[题目链接](http://poj.org/problem?id=2083)

```cpp
#include<iostream>  
#include<cstdio>  
#include<cmath>  
using namespace std;  
  
char map[731][731];  
  
void dfs(int n,int x,int y)  
{  
    int size;  
    if(n==1)  
    {  
        map[x][y]='X';  
        return ;  
    }  
    size=pow(3.0,n-2);  
    ______;    // 填空
    ______;    // 填空
    ______;    // 填空
    ______;    // 填空
    ______;    // 填空
}  
int main(void)  
{  
    int i,j,n,size;  
    while(scanf("%d",&n)!=EOF)  
    {  
        if(n==-1)  
            break;  
        size=pow(3.0,n-1);  
        for(i=1;i<=size;i++)  
        {  
            for(j=1;j<=size;j++)  
                map[i][j]=' ';  
        }  
        dfs(n,1,1);  
  
        for(i=1;i<=size;i++)  
        {  
            for(j=1;j<=size;j++)  
                printf("%c",map[i][j]);  
            printf("\n");  
        }  
        printf("-\n");  
    }  
    return 0;  
}  
```

## 乘法游戏

[题目链接](http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1602)

乘法游戏用一个序列的牌来玩的，每张牌都包含一个正整数作为其分值。当玩家将一张牌从序列中取出时，记录下这张牌与它左右两边牌的分值三者的乘积，将该乘积加入总分。这意味着第一张牌和最后一张牌不能被取走。取到最后，只有两张牌被留在序列中。

比如，如果牌的序列为 10，1，50，20，5。其中，10 和 5 是不可被移动的。

假设，

- 先取走 1 这张牌，则得到得分为 10\*1\*50 = 500。
- 再取走 20，则得到得分 50\*20\*5 = 5000。
- 再取走 50，得到得分 10\*50\*5 = 2500。
- 最后总得分为 500+5000+2500 = 8000。

但用另一种方法，

- 先取走 50，得到得分 1\*50\*20 = 1000。
- 再取走 20，得到得分 1\*20\*5 = 100。
- 再取走 1，得到得分 1\*10\*5 = 50。
- 最后总得分为 1000+100+50 = 1150。

显然第二种方法要比前一种得到的总分要小。
我们的最终目标是找到一种取法使总分最小。

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

unsigned int s[100][100];
int c[100];

void GetScores(int card_count)
{
    int i, j, k, t;
    unsigned int tmp;
    /* init */
    memset(s, 0, sizeof(s));

    for(k = 3; k <= card_count; k++)
    {
        for(i = 0; i < card_count - 2; i++)
        {
            j = i + k - 1;
            s[i][j] = 0xffffffff;
            for(t = i + 1; t < j; t++)
            {
                ______;  // 填空
            }
        }
    }
}

int main(int argc, char* argv[])
{
    int i, card_count = 0;

    while(scanf("%ld", &card_count) != EOF)
    {
        for(i = 0; i < card_count; i++)
            scanf("%ld", c + i);

        GetScores(card_count);
        printf("%lu\n", s[0][card_count-1]);
    }
    return 0;
}
```

## 星际穿越

[题目链接](https://www.nowcoder.com/practice/53e4c208b8cf497086ecd65ef45349bb?tpId=85&tqId=29835&tPage=1&rp=1&ru=/ta/2017test&qru=/ta/2017test/question-ranking)

航天飞行器是一项复杂而又精密的仪器，飞行器的损耗主要集中在发射和降落的过程，科学家根据实验数据估计，如果在发射过程中，产生了 x 程度的损耗，那么在降落的过程中就会产生 x<sup>2</sup> 程度的损耗，如果飞船的总损耗超过了它的耐久度，飞行器就会爆炸坠毁。问一艘耐久度为 h 的飞行器，假设在飞行过程中不产生损耗，那么为了保证其可以安全的到达目的地，只考虑整数解，至多发射过程中可以承受多少程度的损耗？

***输入格式：***
每个输入包含一个测试用例。每个测试用例包含一行一个整数 h（1 &le; h &le; 10^18）。

***输出格式：***
输出一行一个整数表示结果。

## 交叉梯子

[题目链接](http://poj.org/problem?id=2507)

在一个狭窄的街道上矗立着两栋楼，右楼有一个长度为 x 的梯子搭载左楼，左楼有一个长度为 y 的梯子搭在右楼，两梯子的交叉点的高度在 c 处，问这个街道的长度。

***输入格式：***
每行一组数据，表示 x, y, c。

***输出格式：***
给出街道的宽度，精确到小数点后 3 位。

## 奇怪的加法

[题目链接](https://www.patest.cn/contests/pat-b-practise/1074)

有一天，小明自创了一种加法：
规定两个加数的每一位的进制，然后进行加法运算。
比如，规定了每一位的进制为 **"2047"**，给出了两个加数 **"776"** 和 **"1458"**：

- 首先，个位上 6 + 8 按十进制的运算得到的结果为 14，但规定了该位上的进制为 **7 进制**，所以个位上的结果为 0，进位为 2。
- 接下来，十位上 5 + 7 + 2（进位）按十进制的运算得到的结果为 14，但规定了该位上的进制为 **4 进制**，所以十位上的结果为 2，进位为 3。
- 其次，百位上 7 + 4 + 3（进位）按十进制的运算得到的结果为 14，规定了该位上的进制仍为 **0（10）进制**，所以百位上的结果为 4，进位为 1。
- 最后，千位上 1 + 1（进位）按十进制的运算得到的结果为 2，但规定了该位上的进制为 **2 进制**，所以千位上的结果为 0，进位为 1。
- 最终得到的结果为 10420。

***输入格式：***
输入的第一行为给定的 N 位进制表（0 &lt; N &lt; 20）。
下面两行数字分别为不超过 N 位的非负加数。

***输出格式：***
输出一行，为两数计算之和。

## 迷宫城堡

[题目链接](http://acm.hdu.edu.cn/showproblem.php?pid=1269)

为了训练小希的方向感，Gardon 建立了一座大城堡，里面有 N 个房间（N &le; 10000）和 M 条通道（M &le; 100000），每个通道都是单向的，就是说若称某通道连通了 A 房间和 B 房间，只说明可以通过这个通道由 A 房间到达 B 房间，但并不说明通过它可以由 B 房间到达 A 房间。Gardon 需要请你写个程序确认一下是否任意两个房间都是相互连通的，即：对于任意的 i 和 j，至少存在一条路径可以从房间 i 到房间 j，也存在一条路径可以从房间 j 到房间 i。

***输入格式：***
输入包含多组数据，输入的第一行有两个数：N 和 M，接下来的 M 行每行有两个数 a 和 b，表示了一条通道可以从 A 房间来到 B 房间。最后以两个 0 结束。

***输出格式：***
对于输入的每组数据，如果任意两个房间都是相互连接的，输出 "Yes"，否则输出 "No"。
