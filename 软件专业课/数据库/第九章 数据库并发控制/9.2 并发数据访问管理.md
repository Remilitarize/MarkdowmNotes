[toc]

## 并发数据操作引起的问题

- 丢失更新：当两个或多个事务更新同一个数据资源时，最后的更新覆盖了其他事务前面的更新。
- 读脏数据，简称为 "脏读"：一个事务读到另一个事务未提交的更新数据。
- 不可重复读：一个事务两次读同一行数据，但这两次读到的数据不一样。
- 幻读：事务并发执行时发生的一种现象。

## 封锁机制

封锁机制是并发控制的主要手段，封锁是使食物对它要操作的数据有一定的控制能力。

1. 申请加锁：事务在操作前要对它使用的数据提出加锁请求。
2. 获得锁：当条件成熟时，系统允许事务对数据加锁，从而事务获得数据的控制权。
3. 释放锁：完成操作后放弃数据的控制权。

### 封锁模式

- **共享（S）**
	- 用于 **不更改** 或 **不更新** 数据的读取操作。
- **更新（U）**
	- 用于 **可更新** 的资源中，防止当多个操作在读取、锁定以及随后可能进行的资源更新时发生常见形式的死锁。
- **排他（X）**
	- 用于数据 **修改** 操作，确保不会同时对同一资源进行多重更新。
- 意向
	- 用于建立锁的层次结构。
	- 意向共享（IS）
	- 意向排他（IX）
	- 意向排他共享（SIX）
- 架构
	- 在执行依赖于表架构的操作时使用。
	- 架构修改（Sch-M）
	- 架构稳定（Sch-S）
- 大容量更新（BU）
	- 在向表进行大容量数据复制且指定了 TABLOCK 提示时使用。
- 键范围
	- 当使用可序列化事务隔离级别时保护查询读取的行的范围，确保再次运行查询时其他事务无法插入符合可序列化事务查询的行。

### 可以锁定的资源

可以锁定的资源是指可以锁定 SQL Server 中的各种对象，既可以是一个行，也可以是一个表或数据库。

SQL Server 常见的可以锁定的资源

|锁|说明|
|-|-|
|KEY|索引中用于保护可序列化事务中的键范围的行锁|
|PAGE|数据库中的 8KB 页|
|EXTENT|一组连续的 8KB 页|
|TABLE|包括所有数据和索引的整个表|
|FILE|数据库文件|
|RID|用于锁定堆中的单个行的行标识符|
|APPLICATION|应用程序专用的资源|
|METADATA|元数据锁|
|ALLOCATION_UNIT|分配单元|
|DATABASE|整个数据库|

### 锁的兼容性

锁兼容性可以控制多个事务能否同时获取同一资源上的封锁。
如果资源已被另一事务锁定，则仅当请求锁的模式与现有锁的模式相兼容时，才会授予新的封锁请求。

|请求的模式|IS|S|U|IX|SIX|X|
|-|-|-|-|-|-|-|
|意向共享（IS）|是|是|是|是|是|否|
|共享（S）|是|是|是|否|否|否|
|更新（U）|是|是|否|否|否|否|
|意向排他（IX）|是|否|否|是|否|否|
|意向排他共享（SIX）|是|否|否|否|否|否|
|排他（X）|否|否|否|否|否|否|

### 死锁

系统中有两个或两个以上的事务都处于等待状态，并且每个事务都在等待其中另一个事务解除封锁，他才能继续执行下去，结果造成任何一个事务都无法继续执行，这种现象称系统进入了 **"死锁"**。

可以使用动态管理视图 `sys.dm_tran_locks` 或系统存储过程 `sp_lock` 来查看事务使用锁的信息。
