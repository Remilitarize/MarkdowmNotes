[toc]

- 数据传送累指令分类：
	- 通用传送类指令：`MOV`
	- 获取有效地址指令：`LEA`
	- 获取地址指针指令：`LDS` / `LES`
	- 标志传送指令：`LAHF` / `SAHF`
	- 数据交换指令：`XCHG`
	- 字节转换指令：`XLAT`
	- 堆栈操作治疗你个：`PUSH` / `POP` / `PUSHF` / `POPF`
- 共同点
	- 除指令 `SAHF` / `POPF` 之外，其他指令不影响 PSW（微处理器状态字）中的各标志位。
	- 当指令中有两个操作数时，第一个操作数是目的操作数，第二个操作数是源操作数。
	- 目的操作数的寻址方式一定不能为 **立即数** 和 **段寄存器 CS** 。

## 通用传送类指令

- 语法：`MOV DST, SRC; (DST) ← (SRC)`
- 说明：将 SRC 中的一个字节或一个字传送到 DST 所指定的位置。

![MOV 指令的传送路径](http://oxnec2zdn.bkt.clouddn.com/microcomputer/MOV.png)

例：

```
mov ax, 0210H; (ax) ← 0210H
mov [bx], ax; ((bx)) ← (ax)
mov bl, vyte ptr var1 + 5; (bi) ← (var1 + 5)
```

注意：

- 特别注意 `MOV` 指令不能直达的路径：
	- 立即数 X&rarr; 段寄存器
	- 存储单元 X&rarr; 存储单元
	- 段寄存器 X&rarr; 段寄存器
- 对于双操作数指令，两个操作数的 **类型** 必须匹配。
	- 两个都指定了类型，则必须一致，否则指令出错。
	- 两者之一指定了类型，一般指令无错。
	- 两者都无类型，则指令出错。
- 对于操作数的类型：
	- **立即数** 是 **无类型** 的。
	- **不含变量名** 的直接寻址、寄存器间接寻址、寄存器相对寻址、基址变址寻址、基址变址且相对寻址的操作数也是 **无类型** 的。
	- 利用 `PTR` 操作符可 **指定或暂时改变** 存储单元的类型。

## 取有效地址指令

- 语法：`LEA REG16, MEM`
- 说明：将 **源操作数的有效地址（偏移地址）** 送入 16 位寄存器 REG16。
- 注意：源操作数 MEM 只能是 **直接寻址方式**。

例：

```
lea di, var1; (di) ← offset var1
lea bx, var1 + 15; (bx) ← offset var1 + 15
```

## 取地址指针指令

- 语法
	- `LDS REG16, MEM; (DS) ← (MEM + 2), (REG16) ← (MEM)`
	- `LES REG16, MEM; (ES) ← (MEM + 2), (REG16) ← (MEM)`
- 说明：将 **双字变量 MEM** 内容的 **高 16 位送入 DS 或 ES**，**低 16 位送入指定的 RED16** 中。
- 注意：REG16 不允许为 **段寄存器**。

例：

定义变量：
```
table db 10h, 20h, ...
point1 dd 02001000h
point2 dd table
```

有以下指令：

```
lds di, point1; (ds) ← 0200h, (di) ← 1000h
les si, point2; (es) ← seg table, (si) ← offset table
```

## 标志传送指令

- 语法：
	- `LAHF ; (AH) ← PSW 寄存器的低 8 位`
	- `SAHF ; PSW 寄存器的低 8 位 ← (AH)`
- 说明：
	- `LAHF` 将 **PSW 寄存器中的低 8 位** 转送到寄存器 AH 中。
	- `SAHF` 将 AH 中的内容传送到 **PSW 寄存器中的低 8 位** 中。

## 数据交换指令

- 语法：`XCHG DST, SRC; DST ←→ SRC`
- 说明：完成两个操作数之间数据的交换。
- 注意：SRC 和 DST 可以是寄存器，也可以是存储单元，但两者不能同时为 **存储单元**。

## 字节转换指令

- 语法：`XLAT ; (AL) ← ((BX) + (AL))`
- 说明：
	- 将 **有效地址为 (BX) + (AL) 的存储单元的内容送入 AL**。
	- 适用于两个代码之间的转换。

## 堆栈操作指令

堆栈是采用 **后进先出 LIFO** 的操作方式，由普通的存储单元构成的一块特殊的存储区域。
堆栈指针 SP 总是指向 **栈顶（从高地址空间起始）**。

- 语法：
	- 压入堆栈指令
		- `PUSH SRC; 将 SRC 压入堆栈，即 (SP) ← (SP) - 2, (SP) ← (SRC)`
		- `PUSHF ; 将 PSW 压入堆栈，即 (SP) ← (SP) -2, (SP) ← (PSW)`
	- 弹出堆栈指令
		- `POP DST; 从堆栈弹出 DST，即 (DST) ← (SP), (SP) ← (SP) + 2`
		- `POPF ; 从堆栈弹出 PSW，即 (PSW) ← (SP). (SP) ← (SP) + 2`
- 说明：
	- SRC 和 DST 必须是 **字型** 的。

例：

```
PUSH AX
PUSH BX
POP CX
```

|指针|堆栈|指针|堆栈|指针|堆栈|指针|堆栈|
|-|-|-|-|-|-|-|-|-|-|
|&nbsp;|&nbsp;|&nbsp;|&nbsp;|SP|BX|&nbsp;|BX|
|&nbsp;|&nbsp;|SP|AX|&nbsp;|AX|SP|AX|
|SP|(栈底)|&nbsp;|(栈底)|&nbsp;|(栈底)|&nbsp;|(栈底)|
