[toc]

## 插入排序

排序问题的 **形式化描述**：

- 输入：n 个数的一个序列 `<a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>>`。
- 输出：输入序列的一个排序 `<a<sub>1</sub>', a<sub>2</sub>', ..., a<sub>n</sub>'>`，满足 a<sub>1</sub>&prime; &le; a<sub>2</sub>&prime; &le; ... &le; a<sub>n</sub>&prime;。

对于 **少量元素** 的排序，插入排序是一个有效的算法。

自然语言：

1. 从无序序列中取出一个数存入 `key`。
2. `key` 依次从后向前与有序序列中的每个数进行比较。
3. 如果比较的数大于 `key`，则将其后移，否则 `key` 就赋值给当前数的后一个数。
4. 若无序序列中仍存在数，则重新执行 1，否则结束。

伪代码：

INSERTION_SORT(A)

```
for j = 2 to A.length
    key = A[j]
    i = j - 1
    while i > 0 and A[i] > key
        A[i + 1] = A[i]
        i = i - 1
    A[i + 1] = key
```

图形化描述：

![InsertionSort](http://oxnec2zdn.bkt.clouddn.com/Algorithm/insertionsort.png)

循环不变式：

在第 1~8 行的 `for` 循环的每次迭代开始时，子数组 `A[1 .. j-1]` 由原来在 `A[1 .. j-1]` 中的元素组成，但已按序排列。

### 循环不变式与插入排序的正确性

关于循环不变式，必须证明三条性质：

- 初始化：循环的第一次迭代之前，它为真。
- 保持：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。
- 终止：在循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法的正确性。

对于插入排序的循环不变式，证明其正确性：

- 初始化：第一次循环迭代之前（当 j = 2 时），循环不变式成立。
    - 显然 `j &le; A.length`。
    - 此时 `A[1 .. j - 1]` 仅由单个元素 `A[1]` 组成，而单个元素本身就是有序的。
- 保持：`for` 循环体的第 4~7 行将 `A[j-1]`、`A[j-2]`、`A[j-3]` 等向右移动一个位置，直到找到 `A[j]` 的适当位置。
    - 由于比 `A[j-1]`、`A[j-2]`、`A[j-3]` 等元素小，故 `A[j]` 应放在其前面，且移动过程中，其相对位置没有发生变化。
    - 直至碰到第一个比 `A[j]` 小的数时，`A[j]` 比该数大，则应该放在其后面，由于后面的数已经依次向后移动一个位置，故可以直接插入。
    - 此时的 `A[1 .. j]` 由原来在 `A[1 .. j]` 中的元素组成，但已按序排列。
    - 对 `for` 循环的下一次迭代需要增加 `j` 保持循环不变式。
- 终止：导致 for 循环终止的条件是 `j > A.length = n`，因为每次迭代 `j` 增加 1，那么必有 `j = n + 1`，即 `j - 1 = n`。
    - 子数组 `A[1 .. n]` 由原来在 `A[1 .. n]` 中的元素组成，但已按序排列。
    - 其中，`A[1 .. n]` 就是整个数组，那么循环结束时整个数组已排序。
- 因此算法正确。

### 伪代码中的一些约定

- 缩进表示块结构。
- `while`、`for` 与 `repeat-until` 等循环结构以及 `if-else` 等条件结构与高级语言的对应结构具有类似的解释。
    - 当一个 `for` 循环每次迭代增加其计数器时，使用关键字 `to`。
    - 当一个 `for` 循环每次迭代减少其计数器时，使用关键字 `downto`。
    - 当循环计数器以大于 1 的一个量改变时，该改变量跟在可选关键词 `by` 之后。
- 符号 `//` 表示该行后面部分是个注释。
- 形如 `i = j = e` 的多重赋值将表达式 `e` 的值赋给变量 `i` 和 `j`。
    - 等价于 `i = e` `j = e`。
- 变量是局部于给定过程的。若无显式说明，我们不使用全局变量。
- 数组元素通过 `数组名[下标]` 这样的形式访问。
    - `A[i]` 表示数组 A 中第 i 个元素。
    - 记号 `..` 用于表示数组中值的一个范围。
    - `A[1 .. j]` 表示 A 的一个子数组，包含 j 个元素 `A[1]`、`A[2]`、...、`A[j]`。
- 复合数据通常被组织成对象，对象又由属性组成。
    - 使用面向对象编程语言的语法来访问特定的属性：`对象名.属性名`。
    - 一个数组或对象的变量看作指向表示数组或对象的数据的一个指针。
    - 属性记号可以串联。
    - 当一个指针根本不指向任何对象，我们赋给它特殊值 `NIL`。
- 按值把传参数传递给过程。
- 一个 `return` 语句立刻将控制返回到调用过程的调用点。
    - 允许在单一的 `return` 语句中返回多个值。
- 布尔运算符 `and` 和 `or` 都是短路的。
- 关键词 `error` 表示因为已被调用的过程情况不对而出现了一个错误。

### 练习答案

#### 题目 2.1-1

以图形化描述为模型，说明 INSERTION-SORT 在数组 A = `<31, 41, 59, 26, 41, 58>` 上的执行过程。

***解答：***

![答案2-1-1](http://oxnec2zdn.bkt.clouddn.com/Algorithm/daan2-1-1.png)

#### 题目 2.1-2

重写过程 INSERTION-SORT，使之按非升序（而不是非降序）排序。

***解答：***

INSERTION-SORT(A)

```
for j = 2 to A.length
    key = A[j]
    i = j - 1
    while i > 0 and A[i] < key
        A[i + 1] = A[i]
        i = i + 1
    A[i + 1] = key
```

#### 题目 2.1-3

考虑以下查找问题：

- 输入：n 个数的一个序列 A = `<a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>>` 和一个值 v。
- 输出：下标 i 使得 v = `A[i]` 或者当 v 不在 A 中出现时，v 为特殊值 NIL。

写出线性查找的伪代码，它扫描整个序列来查找 v。
使用一个循环不变式来证明你的算法是正确的。确保你的循环不变时满足三条必要的性质。

***解答：***

SEARCH(A, v)

```
for i = 1 to A.length
    if A[i] = v
        return i
return NIL
```

循环不变式：
在第 1~3 行的 `for` 循环的每个迭代开始时，子数组 `A[1 .. i-1]` 由原来在 `A[1 .. j-1]` 中的元素组成，但其中的每个元素均不等于要查找的值 v。

证明：

- 初始化：第一次循环迭代之前（i = 1）时，循环不变式显然成立。
- 保持：循环体第 2~3 行依次与要查找的值 v 进行比较，直到找到与 v相等的值。
- 终止：循环终止的条件有两个，当找到与 v 相等的值时，直接返回下标；当 `i > A.length` 时，返回特殊值 NIL。

#### 题目 2.1-4

考虑把两个 n 位二进制证书加起来的问题，这两个证书分别存储在两个 n 元数组 A 和 B 中，这两个整数的和应按二进制形式存储在一个 (n+1) 元数组 C 中。请给出该问题的形式化描述，并写出伪代码。

***解答：***

形式化描述：

- 输入：n 个数的一个序列 A = `<a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>>` 和 n 个数的一个序列 B = `<b<sub>1</sub>, b<sub>2</sub>, ..., b<sub>n</sub>>`。
- 输出：(n+1) 个数的一个序列 C = `<c<sub>1</sub>, c<sub>2</sub>, ..., c<sub>n</sub>>`

伪代码：

BINARY_ADD(A, B)

```
carry = 0
for j = A.length + 1 downto 2
    C[j] = (A[j-1] + B[j-1] + carry) % 2
    carry = (A[j-1] + B[j-1] + carry) / 2
C[j] = carry
return C
```

## 分析算法

分析可能指出不止一个可行的候选算法，但往往可以抛弃几个较差的算法。

我们假设一个单处理器计算模型 —— *随机访问机（RAM）*。
该单处理器指出：

- 指令一条接一条地执行，没有并发操作。
- 只包含真实计算机常见的指令，不包含特殊指令。
    - 算术指令（加法、减法、乘法、除法、取余、向下取整、向上取整）
    - 数据移动指令（装入、存储、复制）
    - 控制指令（条件与无条件转移、子程序调用与返回）
- 这些指令所需时间都为 **常量**。

真实计算机包含一些上面未列出的指令，这些指令代表了 RAM 模型中的一个 *灰色区域*。
尽量避免 RAM 模型中这样的灰色区域。
但是，当 k 是一个足够小的正整数时，我们将把 *2<sub>k</sub> 的计算看作一个常量时间的操作*。

### 插入排序算法的分析

**输入规模** 的最佳概念依赖于研究的问题。
对许多问题，最自然的量度是 **输入中的项数**。

一个算法在特定输入上的 **运行时间** 是指执行的基本操作数或步数。
我们假定第 i 行的每次执行需要时间 c<sub>i</sub>，其中 c<sub>i</sub> 是一个常量。

注意，当一个 `for` 或 `while` 循环按通常的方式（即由于循环头中的测试）退出时，**执行测试的次数比执行循环体的次数多 1**。

INSERTION_SORT(A)

```
                                    代价    次数
for j = 2 to A.length               c1      n
    key = A[j]                      c2      n-1
    i = j - 1                       c3      n-1
    while i > 0 and A[i] > key      c4      ∑tj
        A[i + 1] = A[i]             c5      ∑(tj-1)
        i = i - 1                   c6      ∑(tj-1)
    A[i + 1] = key                  c7      n-1
```

则总时间 `T(n)` 为代价与次数列对应元素之积求和。
T(n) = c<sub>1</sub>n + c<sub>2</sub>(n-1) + c<sub>3</sub>(n-1) + c<sub>4</sub>&Sigma;<sub>j=2</sub><sup>n</sub>t<sub>j</sub> + c<sub>5</sub>&Sigma;<sub>j=2</sub><sup>n</sub>(t<sub>j</sub>-1) + c<sub>6</sub>&Sigma;<sub>j=2</sub><sup>n</sub>(t<sub>j</sub>-1) + c<sub>7</sub>(n-1)

若输入数组已排好序，则出现 **最佳情况**。
即每次取出一个值，总存在 `A[i] ≤ key`。
此时的运行时间为：
T(n)
= c<sub>1</sub>n + c<sub>2</sub>(n-1) + c<sub>3</sub>(n-1) + c<sub>4</sub>(n-1) + c<sub>7</sub>(n-1)
= (c<sub>1</sub> + c<sub>2</sub> + c<sub>3</sub> + c<sub>4</sub> + c<sub>7</sub>)n - (c<sub>2</sub> + c<sub>3</sub> + c<sub>4</sub> + c<sub>7</sub>)
我们可以把该运行时间表示为 *an + b*，其中常量 a，b 依赖于语句代价 c<sub>i</sub>。

若输入数组已反向排序，则导致 **最坏情况**。
即每取出一个值，总存在 `A[i] > key`。
此时的运行时间为：
T(n)
= c<sub>1</sub>n + c<sub>2</sub>(n-1) + c<sub>3</sub>(n-1) + c<sub>4</sub>(n(n+1)/2 - 1) + c<sub>5</sub>n(n-1)/2 + c<sub>6</sub>n(n-1)/2 + c<sub>7</sub>(n-1)
= (c<sub>5</sub>/2 + c<sub>6</sub>/2 + c<sub>7</sub>/2)n<sup>2</sup> + (c<sub>1</sub> + c<sub>2</sub> + c<sub>3</sub> + c<sub>4</sub>/2 - c<sub>5</sub>/2 - c<sub>6</sub>/2 + c<sub>7</sub>)n - (c<sub>2</sub> + c<sub>3</sub> + c<sub>4</sub> + c<sub>7</sub>)
我们可以把该运行时间表示为 *an<sup>2</sup> + bn + c*，其中常量 a，b，c 依赖于语句代价 c<sub>i</sub>。

### 最坏情况与平均情况分析

往往集中于只求 **最坏情况运行时间**，即对规模为 n 的任何输入，算法的最长运行时间。

- 一个算法的最坏情况运行时间给出了任何输入的运行时间的一个上界。
- 对某些算法，最坏情况经常出现，
- 平均情况往往与最坏情况一样差。

### 增长量级

对于插入排序，最坏情况运行时间表示为 an<sup>2</sup> + bn + c，其中常量 a，b 和 c 依赖于语句代价 c<sub>i</sub>。
但我们不但忽略实际的语句代价，也要忽略抽象的代价 c<sub>i</sub>。
即做出一种更简化的抽象，即真正感兴趣的是运行时间的 **增长率** 或 **增长量级**。

- 对于 an<sup>2</sup> + bn + c，我们只考虑公式中 **最重要的项**（即 an<sup>2</sup>）。
    - 因为当 n 的值很大时，低阶项相对来说不太重要。
- 同时忽略最重要的项的 **常系数**。
    - 因为对于大的输入，在确定计算效率时常量因子不如增长率重要。

当我们做出以上两项忽略时，只剩下最重要的项中的因子 n<sup>n</sup>。
我们记插入排序具有最坏情况运行时间 **&Theta;(n<sup>2</sup>)**。

- 如果一个算法的最坏情况运行时间具有比另一个算法更低的增长量级，那么我们通常认为前者比后者更有效。
- 由于常量因子和低阶项，对于小的输入，运行时间具有较高增长量级的一个算法与运行时间具有较低增长量级的另一个算法相比，可能需要较少的时间。
- 但是对足够大的输入，一定是具有更低的增长量级的算法运行得更快。

### 练习

#### 题目 2.2-1

用 &Theta; 记号表示函数 n<sup>3</sup>/1000 - 100n<sup>2</sup> - 100n + 3。

***解答：***
&Theta;(n<sup>3</sup>)

#### 题目 2.2-2

考虑排序存储在数组 A 中的 n 个数，首先找出 A 中的最小元素并将其与 A[1] 中的元素进行交换。接着找出 A 中次最小元素并将其与 A[2] 中的元素进行交换。对 A 中前 n-1 个元素按该方式继续。

1. 该算法称为 **选择算法**，写出其伪代码。
2. 该算法维持的循环不变时是什么？
3. 为什么他它只需要对前 n-1 个元素，而不是对所有 n 个元素运行？
4. 用 &Theta; 记号给出选择排序的最好情况与最坏情况运行时间。



