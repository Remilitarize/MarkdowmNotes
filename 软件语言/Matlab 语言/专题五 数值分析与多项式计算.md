## 数据统计分析

### 求最大元素与最小元素

***调用格式：***

- `max()`：求向量或矩阵的最大元素
- `min()`：求向量或矩阵的最小元素
- 当参数为 **向量** 时，函数具有两种调用格式：
    - `y = max(X)`：返回向量 `X` 的最大值并存入 `y`，其中复数元素按 *模* 取最大值。
    - `[y, k] = max(X)`：返回最大值 `y` 以及最大值对应的元素序号 `k`。
- 当参数为 **矩阵** 时，函数具有三种调用格式：
    - `max(A)`：返回一个行向量，向量的第 i 个元素是矩阵 `A` 的第 i 列上的最大值。
    - `[Y, U] = max(A)`：返回记录 `A` 每列最大值的行向量 `Y` 以及记录每列最大值元素行号的 `U`。
    - `max(A, [], dim)`：`dim` 取值为 1 或 2。
        `dim` 取值为 1 时，该函数功能和 `max(A)` 完全相同。
        `dim` 取值为 2 时，该函数返回一个列向量，其第 i 个元素是矩阵 `A` 的第 i 行上的最大值。

### 求矩阵的平均值和中值

***概念：***

- **平均值**：指 *算术平均值*，即每项数据之和除以项数。
- **中值**：指在数据序列中其值的大小恰好处于中间的元素。
    - 如果数据格式为 *奇数*，则取值为大小位于 **中间的元素**。
    - 如果数据格式为 *偶数*，则取值为 **中间两个元素的平均值**。

***调用格式：***

- `mean()`：求算术平均值。
- `median()`：求中值。

> 具体格式类似上面的调用格式。

### 求和与求积

***调用格式：***

- `sum()`：求和函数。
- `prod()`：求积函数。

> 具体格式类似上面的调用格式。

### 累加和与累乘积

***概念：***

设 $latex U = (u_1, u_2, \cdots, u_n)$ 是一个向量，`V`、`W` 是与 `U` 等长的另外两个向量，并且

$$ 
V = (\sum_{i=1}^{1}u_i, \sum_{i=1}^{2}u_i, \cdots, \sum_{i=1}^{n}u_i) \\\\
W = (\prod_{i=1}^{1}u_i, \prod_{i=1}^{2}u_i, \cdots, \prod_{i=1}^{n}u_i)
$$

则分别称 `V`、`W` 为 `U` 的 **累加和向量** 和 **累乘积向量**。

***调用格式：***

- `cumsum()`：累加和函数。
- `cumprod()`：累乘积函数。

### 标准差与相关系数

***概念：***

**标准差** 用于计算数据皮哪里平均数的距离的平均值，其计算公式为：

$$
S_1 = \sqrt{\frac{1}{N-1} \sum_{i=1}^{N} (x_i - \overline{x})^2} \\\\
S_2 = \sqrt{\frac{1}{N} \sum_{i=1}^{N} (x_i - \overline{x})^2}
$$

**相关系数** 能够反映两组数据序列之间相互关系，其计算公式为：

$$
r = \frac{\sum (x_i - \overline{x})(y_i - \overline{y})}{\sqrt{\sum (x_i - \overline{x})^2 \sum (y_i - \overline{y})^2}}
$$

***调用格式：***

- `std()`：计算标准差函数。
- 三种调用格式：
    - `std(X)`：计算向量 `X` 的标准差。
    - `std(A)`：计算矩阵 `A` 的各列的婊准差。
    - `std(A, flag, dim)`：`flag` 取值为 0 或 1，`dim` 取值为 1 或 2。
        - 当 `flag` 取值为 0 时，按 $latex S_1$ 所列公式计算样本标准差。
        - 当 `flag` 取值为 1 时，按 $latex S_2$ 所列公式计算总体标准差。
        - 默认情况下，`flag` 取值为 0，`dim` 取值为 1。
- `corrcoef()`：相关系数函数。
- 两种调用格式：
    - `corrcoef(A)`：返回由矩阵 A 所形成的一个相关系数矩阵。
        - 第 i 行第 j 列的元素表示原矩阵 `A`中 **第 i 列和第 j 列** 的相关系数。
    - `corrcoef(A)`：求 `X`、`Y` 向量之间的相关系数。

### 排序

***调用格式：***

- `sort()`：排列函数。
- 两种调用格式：
    - `sort(X)`：对向量 X 按 **升序排列**。
    - `[Y, I] = sort(A, dim, mode)`：`Y` 是排列后的矩阵，`I` 记录 `Y` 中的元素在 `A` 中的位置，`mode` 指明升序或降序。
        - 取值为 `ascend`，则为升序。
        - 取值为 `descend`，则为降序。
        - 默认为升序。

## 多项式计算

### 多项式的表示

在 Matlab 中，n 次多项式用一个长度为 n+1 的行向量表示。
如有 n 次多项式：

$$ p(x) = a_n x^{n} + a_{n-1}x^{n-1} + \cdots + a_1 x + a_0 $$

则在 Matlab 中，$latex p(x)$ 表示为向量形式为：

$$ [a_n, a_{n-1}, \cdots, a_1, a_0] $$

注意：

- 多项式系数向量的顺序是 *从高到低*。
- 多项式系数向量包含 0 次项系数，所以长度为多项式最高次数加 1。
- 没有的项用 0 补足。

### 多项式的四则运算

- 加减运算
    - 多项式的加减运算非常简单，即对应向量相加减。
    - 不同次数的多项式需要将低次多项式前面向高次多项式用 0 补齐。
- 乘法运算
    - `conv(p1, p2)`：多项式相乘运算。
- 除法运算
    - `[Q, r] = deconv(p1, p2)`：多项式相除运算。
    - `Q` 返回多项式 `p1` 除以 `p2` 的商式。
    - `r` 返回多项式 `p1` 除以 `p2` 的余式。
- `deconv` 是 `conv` 函数的 *逆函数*。
    - $latex p1 = conv(Q, p2) + r$

### 多项式的求导

- `polyder()`：多项式求导函数。
- 调用格式：
    - `p = polyder(P)`：求多项式的导函数。
    - `p = polyder(P, Q)`：求 P·Q 的导函数。
    - `[p, q] = polyder(P, Q)`：求 P/Q 的导函数。
        - `p` 中存入导函数的分子。
        - `q` 中存入导函数的分母。

### 多项式的求值

- `polyval(p, x)`：代数多项式求值。
    - 将 `x` 中每个元素求多项式的值。
- `polyvalm(p, A)`：矩阵多项式求值。
    - `x` 为方阵。
    - 按矩阵运算求多项式的值。

设 A 为方阵，P 代表多项式 $latex x^3-5x^2+8$，那么

- `polyval(A, P)` 的含义是 `A.*A.*A - 5.*A.*A + 8*ones(size(A))`。
- `polyvalm(A, P)` 的含义是 `A*A*A - 5*A*A + 8*eye(size(A))`。

### 多项式的求根

- `roots(p)`：多项式求根函数。
- `poly(x)`：通过已知多项式的全部根，建立多项式。

## 数据插值

***计算机制：***

通过 **函数逼近** 的方法，构造一个近似函数 $latex \phi(x)$ 逼近未知函数 $latex f(x)$ 使得 $latex \phi(x) \approx f(x)$，即

$$ \phi (x_1i = y(x_i) \quad (i = 1, 2, \cdots, n) $$

***一维插值调用格式：***

- `interp1()`：一维数据插值。
- `y1 = interp1[x, y, x1, method]`
    - `x`、`y` 是两个等长的已知向量，分别表示采样点和采样值。
    - `x1` 是一个向量或标量，表示要插值的点。
- `method` 参数指定特定的插值方法。
    - `linear`：**线性插值**，默认方法。
        - 将与插值点靠近的两个数据点用直线连接，然后在直线上选取对应插值点的数据。
    - `nearest`：**最近点插值**。
        - 选取最近样本点的值作为插值数据。如果是中间点，则取后一个数据点的值。
    - `phip`：**分段 3 次埃尔米特插值**。
        - 采用分段三次多项式，除满足插值条件，还需满足再若干节点处相邻段插值函数的 **一阶导数** 相等。
        - 曲线光滑，保形性。
    - `spline`：**3 次样条插值**。
        - 每个分段内构造一个三次多项式，使其插值函数除满足插值条件外，还要求在各节点处具有连续的 **一阶和二阶导数**。

> 多项式次数并非越高越好。次数越高，越容易产生震荡而偏离原函数，这种现象称为 **龙格** 现象。

```matlab
x = [0, 3, 5, 7, 9, 11, 12, 13, 14, 15];
y = [0, 1.2, 1.7 2.0, 2.1, 2.0, 1.8, 1.2, 1.0, 1.6];
x1 = 0: 0.1: 15;
y1 = interp1(x, y, x1, 'spline');
plot(x1, y1);
```

***四种方法的比较：***

- 线性插值和最近点插值方法比较简单。
    - 线性插值方法的计算量与样本点 n 无关，n 越大，误差越小。
- 3 次埃尔米特插值和 3 次样条插值都能保证曲线的光滑性。
    - 3 次埃尔米特插值具有保形性。
    - 3 次样条插值要求其二阶导数也连续，所以插值函数的性态更好。

***二维插值调用格式：***

- `interp2()`：二维插值函数。
- `z1 = interp2(x, y, z, x1, y1, method)`

## 曲线拟合

***计算机制：***

通过 **函数逼近** 的方法，构造近似函数 $latex g(x)$ 逼近未知函数 $latex f(x)$ 使得误差 $latex \delta_i = g(x_i) - f(x_i) \quad (i = 1, 2, 3, \cdots, n)$ 通过 **最小二乘法** 下达到最小。

**最小二乘法**（又称 *最小平方法*）是一种数学优化技术，它通过 **最小化误差的平方和** 来寻找数据的最佳函数匹配。

***调用格式：***

- `polyfit()`：多项式拟合函数。
- 三种调用格式：
    - `P = polyfit(X, Y, m)`
    - `[P, S] = polyfit(X, Y, m)`
    - `[P, S, mu] = polyfit(X, Y, m)`
    - 根据样本数据 `X` 和 `Y`，产生一个 `m` 次多项式 `P` 及其在采样点误差数据 `S`。
    - `mu` 是一个二元向量，`mu(1)` 是 `mean(X)`，`mu(2)` 是 `std(X)`。

***例子：***

已知某国人口数据，预测该国 2020 年的人口情况。

> 曲线拟合需要根据统计数据预测已知未统计数据来分析拟合函数的误差。
> 除此之外，还需要根据实际情况以及历史事件对统计数据进行删减。

```matlab
x = 1790: 10: 2010;
y = [3.9, 5.3, 7.2, 9.6, 12.9, 17.1, 23.2, 31.4, 38.6, 50.2, 63.0, 76.0, 92.0, 105.7, 122.8, 131.7, 150.7, 179.3, 203.2, 226.5, 248.7, 281.4, 308.7];
plot(x, y, '*');
p = plotfit(x, y, 3);
polyval(p, 2020);
plot(x, y, '*', x, polyval(p, x));
polyval(p, 2016)
```

得到拟合函数预测 2016 年人口数为 327.0964。
实际为 323.1。
相对误差为 1.24%。

- 据研究，一个国家的人口增长具有如下特点：
    - 发展越平稳，人口增长越有规律。
        - 经济危机以及第二次世界大战均对该国造成影响。
    - 当经济发展到一定水平时，人口增长率反而下降。
- 结论：*在人口增长数据的拟合上，应该将二战后至今之一时期的数据与以前的数据分开处理。*

```matlab
x = 1950: 10: 2010;
y = [150.7, 179.3, 203.2, 226.5, 248.7, 281.4, 308.7];
p = polyfit(x, y, 3)  % 拟合函数次数过高
p = polyfit(x, y, 2);
plot(x, y, '*', x, polyval(p, x));
polyval(p, 2016)
```

得到拟合函数预测 2016 年人口数为 325.1696。
相对误差为 0.64%。
