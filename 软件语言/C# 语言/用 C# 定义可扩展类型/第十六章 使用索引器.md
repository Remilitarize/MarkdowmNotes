[toc]

## 什么是索引器

**索引器** 可被视为一种智能数组。
使用索引器时，语法和使用数组完全相同。

### 不用索引器的例子

通常用 `int` 容纳整数值。
有时 `int` 可以作为二进制标志集合。
使用 **位操作符** 将 `int` 的每一位作为一个标志来使用。

- NOT `~` 操作符：一元操作符，执行按位求补。
- 左移位 `<<` 操作符：二元操作符，执行左位移，最左边的位会被丢弃，最右边用 0 补足。
- OR `|` 操作符：二元操作符，两个操作数中，任何一个的某一位是 1，返回值的对应位置就是 1。
- AND `&` 操作符：二元操作符，只有两个操作数的同一个位置都是 1，返回值的对应位置才是 1。
- XOR `^` 操作符：二元操作符，只有在两个位置的值不同的前提下，返回值的对应位置才是 1。

> 按位操作符从右向左计算位置，最右侧的位是位置 0。

- 把右数第 k 位变为 1：`x|(1<<(k-1))`
- 把右数第 k 位变为 0：`x&~(1<<(k-1))`
- ...

### 同一个例子改用索引器

对于上面的式子过于复杂，我们想像数组一样去设置某一位上的值，这时可以定义一个索引器。

```csharp
struct IntBits
{
	private int bits;

	public IntBits(int initialBitValue)
	{
		bits = initialBitValue;
	}

	public bool this [int index]
	{
		get
		{
			return (bits & (1 << index)) != 0;
		}
		set
		{
			if(value)
				bits |= (1 << index);
			else
				bits &= ~(1 << index);
		}
	}
}
```

- 索引器不是方法，没有参数列表。
- 所有所引起都使用 `this` 关键字取代索引器名。
- 每个类或结构只允许定义一个索引器，而且总是命名为 `this`。
- 和属性一样，索引器也包含 `get` 和 `set` 这两个访问器。
- 索引器声明中指定的 `index` 将用调用索引器时指定的索引值来填充。

> 索引器应对索引值进行范围检查，防止索引器代码发生任何不希望的异常。

### 理解索引器的访问器

```csharp
bool b = bits[6];    // 读取
bits[3] = true;      // 写入
bits[6] ^= true;     // 通过 XOR 取反
```

> 还可以声明只包含 `get` 访问器的索引器（只读索引器），或声明只包含 `set` 访问器的索引器（只写索引器）。

### 对比索引器和数组

- 索引器可以使用 **非数值下标**，而数组只能使用整数下标。
- 索引器能重载，数组则不能。
- 索引器不能作为 `ref` 或 `out` 参数使用，数组元素则可以。

## 接口中的索引器

可在接口中声明索引器。
需要指定 `get` 以及/或者 `set` 关键字，但主体要替换成分号。

```csharp
interface IRawInt
{
	bool this [int index] { get; set; }
}
```

在类中实现接口要求的索引器时，可将索引器的实现声明为 `virtual`，从而允许派类重写 `get` 和 `set` 访问起。
还可以附加借口名称作为前缀，通过显式接口实现语法来实现索引器，索引器的显式实现是非公开和非虚的。
